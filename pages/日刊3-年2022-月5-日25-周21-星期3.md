- # 收藏
	- [浮墨笔记](https://flomoapp.com/)
	  collapsed:: true
		- flomo笔记 使用体验
			- 本笔记部分就是。
			- 标签，我在Logseq里也喜欢标签进行标记，但我觉得Logseq的标签功能已经概括了flomo的标签功能，并且笔记在一起，方便管理。但如果不使用Logseq，或想单独标签出来，flomo是非常好的选择！我现在保存一些摘录文本在flomo中，尝试体验一波。
		- [logseq-flomo-plugin](https://github.com/duiliuliu/logseq-flomo-plugin) 同步 flomo 笔记至 logseq
			- 获取 flomo_session
				- ![](https://wangguanjingji.oss-cn-beijing.aliyuncs.com/picture/Snipaste_2022-05-25_21-10-09.png)
			- flome今日同步
				- 🚀🚀🚀loadind...
				- #☘️.memo <p>#日志-年2022-月5-日23-周22周一</p><p>#日志-每天</p><p>#日志-年2022</p><p>#日志-年2022-月5</p><p>#日志-年2022-周22</p><p>00:30 测试 flomo笔记还行</p><p></p>
				- #☘️.memo <p>#杨超越 #说英雄谁是英雄</p><p>第四位，杨超越饰演的温柔。</p><p></p><p>被质疑我也要说，这几乎是全剧最妙的选角。</p><p></p><p>不是杨超越演技太好，而是她最合适。</p><p></p><p>温柔是一个武林背景极其深厚，和武林各大顶级高手都扯得上关系的浪漫少女，活泼可爱自带侠气，是整部剧里的一抹光。</p><p></p><p>https://f10.baidu.com/it/u=1902050532,174102758&amp;fm=30&amp;app=106&amp;f=JPEG?w=640&amp;h=291&amp;s=A0D23DC87776103748E8A1080300E092</p><p></p><p>看起来很好演的角色，其实不好演，看多了国产剧演活泼可爱少女尬出天际惨案的观众，应该明白我在说什么。</p><p></p><p>杨超越在预告片中以一身红衣女侠扮相出镜，极为惊艳的出场之下，将又美又甜四个字完美演绎。</p><p></p><p></p><p>当时我就觉得这个选角很对。</p><p></p><p>后来和两位男主相遇，她也演出了娇蛮大小姐的味道，情急之下，用背景唬住找茬的人，一壶水泼过去的架势，杨超越演出来我是信的。</p><p></p><p></p><p>但这个人物也有美好温柔的一面，最后和王小石浪迹天涯的也是她。</p><p></p><p>剧中杨超越也演出了这份温柔，从中也能看出她演技的进步。</p><p></p><p></p><p>虽然之前几部剧并不是很成功，但杨超越属于遇到对的角色就能发光的演员，这次她遇到对的角色了。</p>
				- #☘️.memo <p>总体上来说，李木戈这次的选角虽然偏年轻，但完全符合预期。</p><p></p><p>因为这就是一个年轻侠客经历江湖洗礼的故事。接下来，就看这群年轻演员，能否在完成角色之外更进一步，演出整部剧的——格局。</p><p>#说英雄谁是英雄 </p>
				- #☘️.memo <p>《说英雄》热播的过程中，会遭遇五大卫视剧的强烈竞争，网剧方面，聂远秦岚的《传家》、李易峰宋轶的《暗夜行者》，《法医秦明》的最新剧集，都非等闲之辈。</p><p></p><p>《说英雄》能否突出重围，其实也是一大看点。</p><p></p><p>但如果剧集本身品质过硬，则没有什么能阻挡它成为爆款。</p><p></p><p>虽然属于侠客的江湖逐渐远去，刀光剑影也早已变得黯淡。但意气风发的少年壮语、对正道的坚守之心、兄弟之间的情义与纠结，永远打动人。</p><p></p><p></p><p>《说英雄》是早就该改编的武侠剧，偏偏现在才出来，但或许，时间又刚刚好。</p><p></p><p>一个时代有一个时代的武侠，希望《说英雄》能成就这个时代的武侠传奇。</p><p>#说英雄谁是英雄 </p>
				- #☘️.memo <p>#日志-年2022-月5-日225-周22周三</p><p>#日志-每天</p><p>07:59 市场营销学</p><p>想法：可以直接把 刊 直接发布在 Logseq 上，比发在Hexo博客上好。</p><p>现在考虑是</p><p>1. 一个Logseq，LogseqWeb放在本地Logseq里，不区分,要发布什么就添加发布就行(就像生活和工作)</p><p>2. 两个Logseq文件夹，分别放在一个文件夹里。</p><p>反正 Logseq支持打开本地库(文件夹)，要发布的话打开LogseqWeb文件库就行了。</p><p></p><p>我倾向与第一种，但这样隐私问题可能会暴露！</p><p>第二种是(最好的选择了)。</p><p></p><p>大佬的LogseqWeb--github，可以借鉴，但这样不是都发布了吗！适合把Logseq直接当博客的人。</p><p>https://github.com/pengx17/knowledge-garden</p><p>大佬的LogseqWeb</p><p>https://pengx17.github.io/knowledge-garden/</p><p>X浏览器就是有些页面不支持和登录(比如这个)，但非常好用！</p><p></p><p>发现，在Logseq文件(即主目录) =&gt; logseq文件夹 =&gt; 里的文件修改。手机Logseq的样式也能改变(无敌了，现阶段Logseq不支持插件，但这样就能修改样式了 )#惊喜 #Logseq</p><p></p><p>刊</p><p>每天晚上10点从图书馆回寝室总结，但因为11点寝室断电，其实有点赶。</p><p>另外呢，我的文笔不好，要我一下写出有点赶鸭子上架，但如果白天就断续记写 刊，也不知是好是坏。</p><p></p><p>flomo笔记 使用体验</p><p>本笔记就是。</p><p>标签，我在Logseq里也喜欢标签进行标记，但我觉得Logseq的标签功能已经概括了flomo的标签功能，并且笔记在一起，方便管理。但如果不使用Logseq，或想单独标签出来，flomo是非常好的选择！</p> ![flomo image](https://flomo.oss-cn-shanghai.aliyuncs.com/file/2022-05-25/617301/1653440354132A3CCD7A3AE3DE8B6.jpg?OSSAccessKeyId=LTAI4G9PcaGksWVKCPrE1TVL&Expires=1653495074&Signature=0ehk6aDe6xxI3glNmILnWVUuCdg%3D) ![flomo image](https://flomo.oss-cn-shanghai.aliyuncs.com/file/2022-05-25/617301/165344794263124E0AD195947B166.jpg?OSSAccessKeyId=LTAI4G9PcaGksWVKCPrE1TVL&Expires=1653495074&Signature=juMHQYIZm9Gr8vgcZY5x%2BgU3Tmk%3D)
				-
	- [树悲风的图书馆-利器观 (864)](http://www.360doc.cn/userhome.aspx?userid=366082&cid=8)360个人图书馆互联网工具集
	- [QuickLook](https://github.com/QL-Win/QuickLook)
		- QuickLook 是一款 Windows 下的桌面快速预览工具，开源、免费。只需要用鼠标选中文件，然后点击空格，即可预览。就像 macOS 里的那样，支持图片、压缩包、PDF、Office 文档、视频等等。(还没用)
	- 文章-[杨超越发文霸气护爹，怎么还有人diss她？_百科TA说](https://baike.baidu.com/tashuo/browse/content?id=91862aba0e02ef87940abcf6&lemmaId=9686500&fromLemmaModule=list&lemmaTitle=%E6%9D%A8%E8%B6%85%E8%B6%8A&lemmaFrom=tashuo-feed)
	- 文章-[《说英雄》首播：主角演技引热议，杨超越令人惊喜，打戏评价两极](https://baijiahao.baidu.com/s?id=1733668573647467564) 写的真好，比看视频解说带劲的很(以后经常去看他的文章)，晚上看《说英雄谁是英雄》
	- [logseq-dev-theme](https://github.com/pengx17/logseq-dev-theme) #Logseq-主题 当前电脑手机使用！
	- [awesome-logseq](https://github.com/logseq/awesome-logseq#css-themes) 社区创建的很棒的Logseq扩展中心(主题，插件...) #Logseq
	-
-
- # Me
- Logseq Web版(充当博客 和刊 发表)
  collapsed:: true
	- 想法：可以直接把 刊 直接发布在 Logseq 上，比发在Hexo博客上好。
	- 现在考虑是
		- 1. 一个Logseq，LogseqWeb放在本地Logseq里，不区分,要发布什么就添加发布就行(就像生活和工作)
		- 2. 两个Logseq文件夹，分别放在一个文件夹里。
		-
		- 反正 Logseq支持打开本地库(文件夹)，要发布的话打开LogseqWeb文件库就行了。
		- 我倾向与第一种，但这样隐私问题可能会暴露！
		- 第二种是(最好的选择了)。
		- 12:20 这样就好了
		- ![](https://wangguanjingji.oss-cn-beijing.aliyuncs.com/picture/1653452391020.png)
		-
		- 切换库很方便，同时坚果云同步在手机上也OK，手机上操作Logseq与电脑一样，有个小惊喜！下文
		  ![](https://wangguanjingji.oss-cn-beijing.aliyuncs.com/picture/1653452494633.png)
		-
- 下课后的回寝室10分钟，我的效率比平时半小时还快，很有感觉。
- 大佬的[LogseqWeb--github](https://github.com/pengx17/knowledge-garden)，可以借鉴，但这样不是都发布了吗！适合把Logseq直接当博客的人。
- 大佬的[LogseqWeb](https://pengx17.github.io/knowledge-garden/) X浏览器就是有些页面不支持和登录(比如这个)，但非常好用！
-
-
- 发现，在Logseq文件(即主目录) => logseq文件夹 => 里的文件修改。手机Logseq的样式也能改变(无敌了，现阶段Logseq不支持插件，但这样就能修改样式了 ) #惊喜 #Logseq
  collapsed:: true
	- ![](https://wangguanjingji.oss-cn-beijing.aliyuncs.com/picture/165344794263124E0AD195947B166.jpg)
-
- ## 刊
	- 每天晚上10点从图书馆回寝室总结日刊，但因为11点寝室断电，其实有点赶。毕竟学习笔记是最重要的。(现在日刊学习笔记占比不重)
	- 另外呢，我的文笔不好，要我一下写出有点赶鸭子上架。现在直接在Logseq上记些杂碎()。但如果白天就断续记写 刊，也不知是好是坏。
- 难啊，今天学习笔记有没怎么看！(蚊子太多了，受不了)
-
- # SpringMVC(99%笔记是粘贴的)
  collapsed:: true
	- ## MVC理论基础
	  collapsed:: true
		- MVC解释如下：
		  			* M是指业务模型（Model）：通俗的讲就是我们之前用于封装数据传递的实体类。
		  			* V是指用户界面（View）：一般指的是前端页面。
		  			* C则是控制器（Controller）：控制器就相当于Servlet的基本功能，处理请求，返回响应。
		  
		   ![点击查看源网页](https://pics5.baidu.com/feed/d0c8a786c9177f3e5707320277aeb1c39f3d5677.jpeg?token=e4c298063f4efa11fd0f94c2760c252b&s=782834721BC044435C55F4CA0000E0B1)
		  
		   SpringMVC正是希望这三者之间进行解耦，实现各干各的，更加精细地划分对应的职责。最后再将View和Model进行渲染，得到最终的页面并返回给前端（就像之前使用Thymeleaf那样，把实体数据对象和前端页面都给到Thymeleaf，然后它会将其进行整合渲染得到最终有数据的页面，而本教程也会使用Thymeleaf作为视图解析器进行讲解）
	- ## 配置环境并搭建项目
	  collapsed:: true
		- 由于SpringMVC还没有支持最新的Tomcat10（主要是之前提到的包名问题，神仙打架百姓遭殃）所以我们干脆就再来配置一下Tomcat9环境，相当于回顾一下。
		- 下载地址：https://tomcat.apache.org/download-90.cgi
		- 添加SpringMVC的依赖：
		- ``` xml
		  		  <dependency>
		  		    <groupId>org.springframework</groupId>
		  		    <artifactId>spring-webmvc</artifactId>
		  		    <version>5.3.13</version>
		  		  </dependency>
		  ```
		- 接着我们需要配置一下web.xml，将DispatcherServlet替换掉Tomcat自带的Servlet，这里url-pattern需要写为`/`，即可完成替换：
		- ``` xml
		  		  <?xml version="1.0" encoding="UTF-8"?>
		  		  <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
		  		         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		  		         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
		  		         version="4.0">
		  		    <servlet>
		  		        <servlet-name>mvc</servlet-name>
		  		        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		  		    </servlet>
		  		    <servlet-mapping>
		  		        <servlet-name>mvc</servlet-name>
		  		        <url-pattern>/</url-pattern>
		  		    </servlet-mapping>
		  		  </web-app>
		  ```
		- 接着需要为整个Web应用程序配置一个Spring上下文环境（也就是容器），因为SpringMVC是基于Spring开发的，它直接利用Spring提供的容器来实现各种功能，这里我们直接使用注解方式进行配置，不再使用XML配置文件：
		- ``` xml
		  		  <init-param>
		  		            <param-name>contextConfigLocation</param-name>
		  		            <param-value>com.example.config.MvcConfiguration</param-value>
		  		        </init-param>
		  		        <init-param>
		  		            <param-name>contextClass</param-name>
		  		            <param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
		  		        </init-param>
		  ```
		- 如果还是想使用XML配置文件进行配置，那么可以直接这样写：
		- ``` xml
		  		  <init-param>
		  		    <param-name>contextConfigLocation</param-name>
		  		    <param-value>配置文件名称</param-value>
		  		  </init-param>
		  ```
		- 如果你希望完完全全丢弃配置文件，可以直接添加一个类，Tomcat会在类路径中查找实现ServletContainerInitializer 接口的类，如果发现的话，就用它来配置Servlet容器，Spring提供了这个接口的实现类 SpringServletContainerInitializer , 通过@HandlesTypes(WebApplicationInitializer.class)设置，这个类反过来会查找实现WebApplicationInitializer 的类，并将配置的任务交给他们来完成，因此直接实现接口即可：
		- ``` java
		  		  public class MainInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
		  		    @Override
		  		    protected Class<?>[] getRootConfigClasses() {
		  		        return new Class[]{MainConfiguration.class};   //基本的Spring配置类，一般用于业务层配置
		  		    }
		  		  - @Override
		  		    protected Class<?>[] getServletConfigClasses() {
		  		        return new Class[0];  //配置DispatcherServlet的配置类、主要用于Controller等配置
		  		    }
		  		  - @Override
		  		    protected String[] getServletMappings() {
		  		        return new String[]{"/"};    //匹配路径，与上面一致
		  		    }
		  		  }
		  ```
		- 顺便编写一下最基本的配置类：
		- ``` java
		  		  @Configuration
		  		  public class MainConfiguration {
		  		  - }
		  ```
		- 后面我们都采用无XML配置方式进行讲解。
		- ![img](https://img2018.cnblogs.com/blog/738818/201906/738818-20190617214214614-761905677.png)
		- 这样，就完成最基本的配置了，现在任何请求都会优先经过`DispatcherServlet`进行集中处理，下面我们会详细讲解如何使用它。
		- 之后都使用注解开发
	- ## Controller控制器
	  collapsed:: true
		- 介绍
			- 有了SpringMVC之后，我们不必再像之前那样一个请求地址创建一个Servlet了，它使用`DispatcherServlet`替代Tomcat为我们提供的默认的静态资源Servlet，也就是说，现在所有的请求（除了jsp，因为Tomcat还提供了一个jsp的Servlet）都会经过`DispatcherServlet`进行处理。
			  那么`DispatcherServlet`会帮助我们做什么呢？
			  ![点击查看源网页](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F1190675%2F201812%2F1190675-20181203121258033-524477408.png&refer=http%3A%2F%2Fimg2018.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1642058685&t=13fd16796a8b5ed58762c9947f15681f)
			  因此，实际上整个过程我们只需要编写对应请求路径的的Controller以及配置好我们需要的ViewResolver即可，之后还可以继续补充添加拦截器，而其他的流程已经由SpringMVC帮助我们完成了。
		- ### 配置视图解析器和控制器
			- 首先我们需要实现最基本的 页面解析并返回，
			  第一步就是配置视图解析器，这里我们使用Thymeleaf为我们提供的视图解析器，导入需要的依赖：
			- ``` xml
			  			  			  <dependency>
			  			  			    <groupId>org.thymeleaf</groupId>
			  			  			    <artifactId>thymeleaf-spring5</artifactId>
			  			  			    <version>3.0.12.RELEASE</version>
			  			  			  </dependency>
			  ```
			- 配置视图解析器非常简单，我们只需要将对应的`ViewResolver`注册为Bean即可，这里我们直接在配置类中编写：
			- ``` java
			  			  			  @ComponentScan("com.example.controller")
			  			  			  @Configuration
			  			  			  @EnableWebMvc
			  			  			  public class WebConfiguration {
			  			  			  - //我们需要使用ThymeleafViewResolver作为视图解析器，并解析我们的HTML页面
			  			  			    @Bean
			  			  			    public ThymeleafViewResolver thymeleafViewResolver(@Autowired SpringTemplateEngine springTemplateEngine){
			  			  			        ThymeleafViewResolver resolver = new ThymeleafViewResolver();
			  			  			        resolver.setOrder(1);   //可以存在多个视图解析器，并且可以为他们设定解析顺序
			  			  			        resolver.setCharacterEncoding("UTF-8");   //编码格式是重中之重
			  			  			        resolver.setTemplateEngine(springTemplateEngine);   //和之前JavaWeb阶段一样，需要使用模板引擎进行解析，所以这里也需要设定一下模板引擎
			  			  			        return resolver;
			  			  			    }
			  			  			  
			  			  			  	//配置模板解析器
			  			  			  	@Bean
			  			  			    public SpringResourceTemplateResolver templateResolver(){
			  			  			        SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver();
			  			  			        resolver.setSuffix(".html");   //需要解析的后缀名称
			  			  			        resolver.setPrefix("/");   //需要解析的HTML页面文件存放的位置
			  			  			        return resolver;
			  			  			    }
			  			  			  	
			  			  			  	//配置模板引擎Bean
			  			  			  	@Bean
			  			  			    public SpringTemplateEngine springTemplateEngine(@Autowired ITemplateResolver resolver){
			  			  			        SpringTemplateEngine engine = new SpringTemplateEngine();
			  			  			        engine.setTemplateResolver(resolver);   //模板解析器，默认即可
			  			  			        return engine;
			  			  			    }
			  			  			  }
			  ```
			- 别忘了在`Initializer`中添加此类作为配置：
			- ``` java
			  			  			  @Override
			  			  			  protected Class<?>[] getServletConfigClasses() {
			  			  			    return new Class[]{MvcConfiguration.class};
			  			  			  }
			  ```
			- 现在我们就完成了视图解析器的配置，
			  我们接着来创建一个Controller，创建Controller也非常简单，
			  只需在一个类上添加一个`@Controller`注解即可，它会被Spring扫描并自动注册为Controller类型的Bean，然后我们只需要在类中编写方法用于处理对应地址的请求即可：
			- ``` java
			  			  			  @Controller   //直接添加注解即可
			  			  			  public class MainController {
			  			  			  - @RequestMapping("/index")   //直接填写访问路径
			  			  			    public ModelAndView index(){
			  			  			        return new ModelAndView("index");  //返回ModelAndView对象，这里填入了视图的名称
			  			  			      	//返回后会经过视图解析器进行处理
			  			  			    }
			  			  			  }
			  ```
			- 我们会发现，打开浏览器之后就可以直接访问我们的HTML页面了。
			- 而页面中的数据我们可以直接向Model进行提供：
			- ``` java
			  			  			  @RequestMapping(value = "/index")
			  			  			  public ModelAndView index(){
			  			  			    ModelAndView modelAndView = new ModelAndView("index");
			  			  			    modelAndView.getModel().put("name", "啊这");
			  			  			    return modelAndView;
			  			  			  }
			  ```
			- 这样Thymeleaf就能收到我们传递的数据进行解析：
			- ``` html
			  			  			  <!DOCTYPE html>
			  			  			  <html lang="en" xmlns:th="http://www.thymeleaf.org">
			  			  			  <head>
			  			  			    <meta charset="UTF-8">
			  			  			    <title>Title</title>
			  			  			    <script src="static/test.js"></script>
			  			  			  </head>
			  			  			  <body>
			  			  			    HelloWorld！
			  			  			    <div th:text="${name}"></div>
			  			  			  </body>
			  			  			  </html>
			  ```
			- 当然，如果仅仅是传递一个页面不需要任何的附加属性，我们可以直接返回View名称，SpringMVC会将其自动包装为ModelAndView对象：
			- ``` java
			  			  			  @RequestMapping(value = "/index")
			  			  			  public String index(){
			  			  			    return "index";
			  			  			  }
			  ```
			- 还可以单独添加一个Model作为形参进行设置，SpringMVC会自动帮助我们传递实例对象：
				- ``` java
				  				  				  @RequestMapping(value = "/index")
				  				  				  public String index(Model model){  //这里不仅仅可以是Model，还可以是Map、ModelMap
				  				  				    model.addAttribute("name", "yyds");
				  				  				    return "index";
				  				  				  }
				  ```
			- 这么方便的写法，你就说你爱不爱吧，你爱不爱。
			- 注意，一定要保证视图名称下面出现横线并且按住Ctrl可以跳转，配置才是正确的（最新版IDEA）
			- 我们的页面中可能还会包含一些静态资源，比如js、css，因此这里我们还需要配置一下，让静态资源通过Tomcat提供的默认Servlet进行解析，我们需要让配置类实现一下`WebMvcConfigurer`接口，这样在Web应用程序启动时，会根据我们重写方法里面的内容进行进一步的配置：
			- ``` java
			  			  			  @Override
			  			  			  public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
			  			  			    configurer.enable();   //开启默认的Servlet
			  			  			  }
			  			  			  - @Override
			  			  			  public void addResourceHandlers(ResourceHandlerRegistry registry) {
			  			  			    registry.addResourceHandler("/static/**").addResourceLocations("/WEB-INF/static/");   
			  			  			  	//配置静态资源的访问路径
			  			  			  }
			  ```
			- 我们编写一下前端内容：
			  ``` xml
			  			  			  <!DOCTYPE html>
			  			  			  <html lang="en" xmlns:th="http://www.thymeleaf.org">
			  			  			  <head>
			  			  			    <meta charset="UTF-8">
			  			  			    <title>Title</title>
			  			  			      <!-- 引用静态资源，这里使用Thymeleaf的网址链接表达式，Thymeleaf会自动添加web应用程序的名称到链接前面 -->
			  			  			    <script th:src="@{/static/test.js}"></script>
			  			  			  </head>
			  			  			  <body>
			  			  			    HelloWorld！
			  			  			  </body>
			  			  			  </html>
			  ```
			- 创建`test.js`并编写如下内容：
			- ``` js
			  			  			  window.alert("欢迎来到GayHub全球最大同性交友网站")
			  ```
			- 最后访问页面，页面在加载时就会显示一个弹窗，这样我们就完成了最基本的页面配置。相比之前的方式，这样就简单很多了，直接避免了编写大量的Servlet来处理请求。
			-
		- ### @RequestMapping详解
			- 前面我们已经了解了如何创建一个控制器来处理我们的请求，接着我们只需要在控制器添加一个方法用于处理对应的请求即可，之前我们需要完整地编写一个Servlet来实现，而现在我们只需要添加一个`@RequestMapping`即可实现，其实从它的名字我们也能得知，此注解就是将请求和处理请求的方法建立一个映射关系，当收到请求时就可以根据映射关系调用对应的请求处理方法，那么我们就来先聊聊`@RequestMapping`吧，注解定义如下：
			- ``` java
			  			  			  @Mapping
			  			  			  public @interface RequestMapping {
			  			  			    String name() default "";
			  			  			  - @AliasFor("path")
			  			  			    String[] value() default {};
			  			  			  - @AliasFor("value")
			  			  			    String[] path() default {};
			  			  			  - RequestMethod[] method() default {};
			  			  			  - String[] params() default {};
			  			  			  - String[] headers() default {};
			  			  			  - String[] consumes() default {};
			  			  			  - String[] produces() default {};
			  			  			  }
			  ```
			- 其中最关键的是path属性（等价于value），它决定了当前方法处理的请求路径，注意路径必须全局唯一，任何路径只能有一个方法进行处理，它是一个数组，也就是说此方法不仅仅可以只用于处理某一个请求路径，我们可以使用此方法处理多个请求路径：
			- ``` java
			  			  			  @RequestMapping({"/index", "/test"})
			  			  			  public ModelAndView index(){
			  			  			    return new ModelAndView("index");
			  			  			  }
			  ```
			- 现在我们访问/index或是/test都会经过此方法进行处理。
			- 我们也可以直接将`@RequestMapping`添加到类名上，表示为此类中的所有请求映射添加一个路径前缀，比如：
			- ``` java
			  			  			  @Controller
			  			  			  @RequestMapping("/yyds")
			  			  			  public class MainController {
			  			  			  - @RequestMapping({"/index", "/test"})
			  			  			    public ModelAndView index(){
			  			  			        return new ModelAndView("index");
			  			  			    }
			  			  			  }
			  ```
			-
			- 那么现在我们需要访问`/yyds/index`或是`/yyds/test`才可以得到此页面。我们可以直接在IDEA下方的端点板块中查看当前Web应用程序定义的所有请求映射，并且可以通过IDEA为我们提供的内置Web客户端直接访问某个路径。
			  路径还支持使用通配符进行匹配：
			  
			  				* ?：表示任意一个字符，比如`@RequestMapping("/index/x?")`可以匹配/index/xa、/index/xb等等。
			  				* *：表示任意0-n个字符，比如`@RequestMapping("/index/*")`可以匹配/index/lbwnb、/index/yyds等。
			  				* **：表示当前目录或基于当前目录的多级目录，比如`@RequestMapping("/index/**")`可以匹配/index、/index/xxx等。
			- 我们接着来看下一个method属性，顾名思义，它就是请求的方法类型，我们可以限定请求方式，比如：
			- ``` java
			  			  			  @RequestMapping(value = "/index", method = RequestMethod.POST)
			  			  			  public ModelAndView index(){
			  			  			    return new ModelAndView("index");
			  			  			  }
			  ```
			- 现在我们如果直接使用浏览器访问此页面，会显示405方法不支持，因为浏览器默认是直接使用GET方法获取页面，而我们这里指定为POST方法访问此地址，所以访问失败，我们现在再去端点中用POST方式去访问，成功得到页面。
			- 我们也可以使用衍生注解直接设定为指定类型的请求映射：
			- ``` java
			  			  			  @PostMapping(value = "/index")
			  			  			  public ModelAndView index(){
			  			  			    return new ModelAndView("index");
			  			  			  }
			  ```
			- 这里使用了`@PostMapping`直接指定为POST请求类型的请求映射，同样的，还有`@GetMapping`可以直接指定为GET请求方式，这里就不一一列举了。
			-
			- 我们可以使用`params`属性来指定请求**必须携带哪些请求参数**，比如：
			  ``` java
			  			  			  @RequestMapping(value = "/index", params = {"username", "password"})
			  			  			  public ModelAndView index(){
			  			  			      return new ModelAndView("index");
			  			  			  }
			  ```
			  比如这里我们要求请求中必须携带`username`和`password`属性，否则无法访问。它还支持表达式，比如我们可以这样编写：
			  
			  ``` java
			  			  			  @RequestMapping(value = "/index", params = {"!username", "password"})
			  			  			  public ModelAndView index(){
			  			  			      return new ModelAndView("index");
			  			  			  }
			  ```
			  在username之前添加一个感叹号表示请求的不允许携带此参数，否则无法访问，我们甚至可以直接设定一个固定值：
			  
			  ``` java
			  			  			  @RequestMapping(value = "/index", params = {"username ! =test", "password=123"})
			  			  			  public ModelAndView index(){
			  			  			      return new ModelAndView("index");
			  			  			  }
			  ```
			  这样，请求参数username不允许为test，并且password必须为123，否则无法访问。
			  
			  `header`属性用法与`params`一致，但是它要求的是请求头中需要携带什么内容，比如：
			  
			  ``` java
			  			  			  @RequestMapping(value = "/index", headers = "!Connection")
			  			  			  public ModelAndView index(){
			  			  			      return new ModelAndView("index");
			  			  			  }
			  ```
			  那么，如果请求头中携带了`Connection`属性，将无法访问。其他两个属性：
			  
			  				* consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;
			  				* produces:  指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；
		- ### @RequestParam和@RequestHeader详解 **注解获取请求相关参数**
			- 我们接着来看，如何获取到请求中的参数。
			- 我们只需要为方法添加一个形式参数，并在形式参数前面添加`@RequestParam`注解即可：
			- ``` java
			  			  			  @RequestMapping(value = "/index")
			  			  			  public ModelAndView index(@RequestParam("username") String username){
			  			  			    System.out.println("接受到请求参数："+username);
			  			  			    return new ModelAndView("index");
			  			  			  }
			  ```
			- 我们需要在`@RequestParam`中填写参数名称，参数的值会自动传递给形式参数，我们可以直接在方法中使用，注意，如果参数名称与形式参数名称相同，即使不添加`@RequestParam`也能获取到参数值。
			- 一旦添加`@RequestParam`，那么此请求必须携带指定参数，我们也可以将require属性设定为false来将属性设定为非必须：
			- ``` java
			  			  			  @RequestMapping(value = "/index")
			  			  			  public ModelAndView index(@RequestParam(value = "username", required = false) String username){
			  			  			    System.out.println("接受到请求参数："+username);
			  			  			    return new ModelAndView("index");
			  			  			  }
			  ```
			- 我们还可以直接设定一个默认值，当请求参数缺失时，可以直接使用默认值：
			- ``` java
			  			  			  @RequestMapping(value = "/index")
			  			  			  public ModelAndView index(@RequestParam(value = "username", required = false, defaultValue = "伞兵一号") String username){
			  			  			    System.out.println("接受到请求参数："+username);
			  			  			    return new ModelAndView("index");
			  			  			  }
			  ```
			- 如果需要使用Servlet原本的一些类，比如：
			- ``` java
			  			  			  @RequestMapping(value = "/index")
			  			  			  public ModelAndView index(HttpServletRequest request){
			  			  			    System.out.println("接受到请求参数："+request.getParameterMap().keySet());
			  			  			    return new ModelAndView("index");
			  			  			  }
			  ```
			- 直接添加`HttpServletRequest`为形式参数即可，SpringMVC会自动传递该请求原本的`HttpServletRequest`对象，同理，我们也可以添加`HttpServletResponse`作为形式参数，甚至可以直接将HttpSession也作为参数传递：
			- ``` java
			  			  			  @RequestMapping(value = "/index")
			  			  			  public ModelAndView index(HttpSession session){
			  			  			    System.out.println(session.getAttribute("test"));
			  			  			    session.setAttribute("test", "鸡你太美");
			  			  			    return new ModelAndView("index");
			  			  			  }
			  ```
			- 我们还可以直接将请求参数传递给一个实体类：
			- ``` java
			  			  			  @Data
			  			  			  public class User {
			  			  			    String username;
			  			  			    String password;
			  			  			  }
			  ```
			- 注意必须携带set方法或是构造方法中包含所有参数，请求参数会自动根据类中的字段名称进行匹配：
			- ``` java
			  			  			  @RequestMapping(value = "/index")
			  			  			  public ModelAndView index(User user){
			  			  			    System.out.println("获取到cookie值为："+user);
			  			  			    return new ModelAndView("index");
			  			  			  }
			  ```
			- `@RequestHeader`与`@RequestParam`用法一致，不过它是用于获取请求头参数的，这里就不再演示了。
			-
		- ### @CookieValue和@SessionAttrbutie **注解获取请求相关参数**
			- 通过使用`@CookieValue`注解，我们也可以快速获取请求携带的Cookie信息：
			- ``` java
			  			  			  @RequestMapping(value = "/index")
			  			  			  public ModelAndView index(HttpServletResponse response,
			  			  			                          @CookieValue(value = "test", required = false) String test){
			  			  			    System.out.println("获取到cookie值为："+test);
			  			  			    response.addCookie(new Cookie("test", "lbwnb"));
			  			  			    return new ModelAndView("index");
			  			  			  }
			  ```
			- 同样的，Session也能使用注解快速获取：
			- ``` java
			  			  			  @RequestMapping(value = "/index")
			  			  			  public ModelAndView index(@SessionAttribute(value = "test", required = false) String test,
			  			  			                          HttpSession session){
			  			  			    session.setAttribute("test", "xxxx");
			  			  			    System.out.println(test);
			  			  			    return new ModelAndView("index");
			  			  			  }
			  ```
			- 可以发现，通过使用SpringMVC框架，整个Web应用程序的开发变得非常简单，大部分功能只需要一个注解就可以搞定了，正是得益于Spring框架，SpringMVC才能大显身手。
		- ### 重定向和请求转发
			- 重定向和请求转发也非常简单，我们只需要在视图名称前面添加一个前缀即可，比如重定向：
			- ``` java
			  			  			  @RequestMapping("/index")
			  			  			  public String index(){
			  			  			    return "redirect:home";
			  			  			  }
			  			  			  - @RequestMapping("/home")
			  			  			  public String home(){
			  			  			    return "home";
			  			  			  }
			  ```
			- 通过添加`redirect:`前缀，就可以很方便地实现重定向，那么请求转发呢，其实也是一样的，使用`forward:`前缀表示转发给其他请求映射：
			- ``` java
			  			  			  @RequestMapping("/index")
			  			  			  public String index(){
			  			  			    return "forward:home";
			  			  			  }
			  			  			  - @RequestMapping("/home")
			  			  			  public String home(){
			  			  			    return "home";
			  			  			  }
			  ```
			- 使用SpringMVC，只需要一个前缀就可以实现重定向和请求转发，非常方便。
		- ### Bean的Web作用域 （有点迷）
			-
			- 在学习Spring时我们讲解了Bean的作用域，包括`singleton`和`prototype`，Bean分别会以单例和多例模式进行创建，而在SpringMVC中，它的作用域被继续细分：
			  				* request：对于每次HTTP请求，使用request作用域定义的Bean都将产生一个新实例，请求结束后Bean也消失。
			  				* session：对于每一个会话，使用session作用域定义的Bean都将产生一个新实例，会话过期后Bean也消失。
			  				* global session：不常用，不做讲解。
			  
			   这里我们创建一个测试类来试试看：
			   ``` java
			   public class TestBean {
			  
			   }
			   ```
			   接着将其注册为Bean，注意这里需要添加`@RequestScope`或是`@SessionScope`表示此Bean的Web作用域：
			   ``` java
			   @Bean
			   @RequestScope
			   public TestBean testBean(){
			   return new TestBean();
			   }
			   ```
			   接着我们将其自动注入到Controller中：
			   ``` java
			   @Controller
			   public class MainController {
			  
			   @Resource
			   TestBean bean;
			  
			   @RequestMapping(value = "/index")
			   public ModelAndView index(){
			   System.out.println(bean);
			   return new ModelAndView("index");
			   }
			   }
			   ```
			   我们发现，每次发起得到的Bean实例都不同，接着我们将其作用域修改为`@SessionScope`，这样作用域就上升到Session，只要清理浏览器的Cookie，那么都会被认为是同一个会话，只要是同一个会话，那么Bean实例始终不变。
			  
			   实际上，它也是通过代理实现的，我们调用Bean中的方法会被转发到真正的Bean对象去执行。
		-
	- ## RestFul风格
	  collapsed:: true
		- 中文释义为**“表现层状态转换”**（名字挺高大上的），它不是一种标准，而是一种设计风格。它的主要作用是充分并正确利用HTTP协议的特性，规范资源获取的URI路径。通俗的讲，RESTful风格的设计允许将参数通过URL拼接传到服务端，目的是让URL看起来更简洁实用，并且我们可以充分使用多种HTTP请求方式（POST/GET/PUT/DELETE），来执行相同请求地址的不同类型操作。
		  因此，这种风格的连接，我们就可以直接从请求路径中读取参数，比如：
		  
		  `http://localhost:8080/mvc/index/123456`
		  
		  我们可以直接将index的下一级路径作为请求参数进行处理，也就是说现在的请求参数包含在了请求路径中：
		  
		  ``` java
		  		  		  @RequestMapping("/index/{str}")
		  		  		  public String index(@PathVariable String str) {
		  		  		      System.out.println(str);
		  		  		      return "index";
		  		  		  }
		  ```
		  注意请求路径我们可以手动添加类似占位符一样的信息，这样占位符位置的所有内容都会被作为请求参数，而方法的形参列表中必须包括一个与占位符同名的并且添加了`@PathVariable`注解的参数，或是由`@PathVariable`注解指定为占位符名称：
		  
		  ``` java
		  		  		  @RequestMapping("/index/{str}")
		  		  		  public String index(@PathVariable("str") String text){
		  		  		      System.out.println(text);
		  		  		      return "index";
		  		  		  }
		  ```
		  如果没有配置正确，方法名称上会出现黄线。
		  
		  我们可以按照不同功能进行划分：
		  
		  			* POST http://localhost:8080/mvc/index  -  添加用户信息，携带表单数据
		  			* GET http://localhost:8080/mvc/index/{id}  -  获取用户信息，id直接放在请求路径中
		  			* PUT http://localhost:8080/mvc/index  -  修改用户信息，携带表单数据
		  			* DELETE http://localhost:8080/mvc/index/{id}  -  删除用户信息，id直接放在请求路径中
		  
		   我们分别编写四个请求映射：
		   ``` java
		   @Controller
		   public class MainController {
		  
		   @RequestMapping(value = "/index/{id}", method = RequestMethod.GET)
		   public String get(@PathVariable("id") String text){
		   System.out.println("获取用户："+text);
		   return "index";
		   }
		  
		   @RequestMapping(value = "/index", method = RequestMethod.POST)
		   public String post(String username){
		   System.out.println("添加用户："+username);
		   return "index";
		   }
		  
		   @RequestMapping(value = "/index/{id}", method = RequestMethod.DELETE)
		   public String delete(@PathVariable("id") String text){
		   System.out.println("删除用户："+text);
		   return "index";
		   }
		  
		   @RequestMapping(value = "/index", method = RequestMethod.PUT)
		   public String put(String username){
		   System.out.println("修改用户："+username);
		   return "index";
		   }
		   }
		   ```
		   这只是一种设计风格而已，各位小伙伴了解即可。
	- ## Interceptor拦截器
	  collapsed:: true
		- 介绍
			- 拦截器是整个SpringMVC的一个重要内容，拦截器与过滤器类似，都是用于拦截一些非法请求，但是我们之前讲解的过滤器是作用于Servlet之前，只有经过层层的拦截器才可以成功到达Servlet，而拦截器并不是在Servlet之前，它在Servlet与RequestMapping之间，相当于DispatcherServlet在将请求交给对应Controller中的方法之前进行拦截处理，它只会拦截所有Controller中定义的请求映射对应的请求（不会拦截静态资源），这里一定要区分两者的不同。
			  ![点击查看源网页](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F4685968-ca4e9021f653c954.png%3FimageMogr2%2Fauto-orient%2Fstrip%257CimageView2%2F2%2Fw%2F1240&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1642340637&t=70d3dd6b52ae01ac76c04d99e6bd95ed)
		- ### 创建拦截器
			- 创建一个拦截器我们需要实现一个`HandlerInterceptor`接口：
			- ``` java
			  			  			  public class MainInterceptor implements HandlerInterceptor {
			  			  			    @Override
			  			  			    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
			  			  			        System.out.println("我是处理之前！");
			  			  			        return true;   //只有返回true才会继续，否则直接结束
			  			  			    }
			  			  			  - @Override
			  			  			    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
			  			  			        System.out.println("我是处理之后！");
			  			  			    }
			  			  			  - @Override
			  			  			    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
			  			  			        System.out.println("我是完成之后！");
			  			  			    }
			  			  			  }
			  ```
			- 接着我们需要在配置类中进行注册：
			- ``` java
			  			  			  @Override
			  			  			  public void addInterceptors(InterceptorRegistry registry) {
			  			  			    registry.addInterceptor(new MainInterceptor())
			  			  			      .addPathPatterns("/**")    //添加拦截器的匹配路径，只要匹配一律拦截
			  			  			      .excludePathPatterns("/home");   //拦截器不进行拦截的路径
			  			  			  }
			  ```
			- 现在我们在浏览器中访问index页面，拦截器已经生效。
			- 得到整理拦截器的执行顺序：
			- > 我是处理之前！
			  
			  我是处理！
			  
			  我是处理之后！
			  
			  我是完成之后！
			- 也就是说，处理前和处理后，包含了真正的请求映射的处理，在整个流程结束后还执行了一次`afterCompletion`方法，其实整个过程与我们之前所认识的Filter类似，不过在处理前，我们只需要返回true或是false表示是否被拦截即可，而不是再去使用FilterChain进行向下传递。
			- 那么我们就来看看，如果处理前返回false，会怎么样：
			- > 我是处理之前！
			- 通过结果发现一旦返回false，之后的所有流程全部取消，那么如果是在处理中发生异常了呢？
			- ``` java
			  			  			  @RequestMapping("/index")
			  			  			  public String index(){
			  			  			    System.out.println("我是处理！");
			  			  			    if(true) throw new RuntimeException("");
			  			  			    return "index";
			  			  			  }
			  ```
			- 结果为：
			- > 我是处理之前！
			  我是处理！
			  我是完成之后！
			- 我们发现如果处理过程中抛出异常，那么就不会执行处理后`postHandle`方法，但是会执行`afterCompletion`方法，我们可以在此方法中获取到抛出的异常。
		- ### 多级拦截器
			- 前面介绍了仅仅只有一个拦截器的情况，我们接着来看如果存在多个拦截器会如何执行，我们以同样的方式创建二号拦截器：
			- ``` java
			  			  			  public class SubInterceptor implements HandlerInterceptor {
			  			  			    @Override
			  			  			    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
			  			  			        System.out.println("二号拦截器：我是处理之前！");
			  			  			        return true;
			  			  			    }
			  			  			  - @Override
			  			  			    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
			  			  			        System.out.println("二号拦截器：我是处理之后！");
			  			  			    }
			  			  			  - @Override
			  			  			    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
			  			  			        System.out.println("二号拦截器：我是完成之后！");
			  			  			    }
			  			  			  }
			  ```
			- 注册二号拦截器：
			- ``` java
			  			  			  @Override
			  			  			  public void addInterceptors(InterceptorRegistry registry) {
			  			  			  	//一号拦截器
			  			  			    registry.addInterceptor(new MainInterceptor()).addPathPatterns("/**").excludePathPatterns("/home");
			  			  			  	//二号拦截器
			  			  			    registry.addInterceptor(new SubInterceptor()).addPathPatterns("/**");
			  			  			  }
			  ```
			- 注意拦截顺序就是注册的顺序，因此拦截器会根据注册顺序依次执行，我们可以打开浏览器运行一次：
			- > 一号拦截器：我是处理之前！
			  二号拦截器：我是处理之前！
			  我是处理！
			  二号拦截器：我是处理之后！
			  一号拦截器：我是处理之后！
			  二号拦截器：我是完成之后！
			  一号拦截器：我是完成之后！
			- 和多级Filter相同，在处理之前，是按照顺序从前向后进行拦截的，但是处理完成之后，就按照倒序执行处理后方法，而完成后是在所有的`postHandle`执行之后再同样的以倒序方式执行。
			- 那么如果这时一号拦截器在处理前就返回了false呢？
			- ``` java
			  			  			  @Override
			  			  			  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
			  			  			    System.out.println("一号拦截器：我是处理之前！");
			  			  			    return false;
			  			  			  }
			  ```
			- 得到结果如下：
			- > 一号拦截器：我是处理之前！
			- 我们发现，与单个拦截器的情况一样，一旦拦截器返回false，那么之后无论有无拦截器，都不再继续。
	- ### 异常处理
	  collapsed:: true
		- 当我们的请求映射方法中出现异常时，会直接展示在前端页面，这是因为SpringMVC为我们提供了默认的异常处理页面，当出现异常时，我们的请求会被直接转交给专门用于异常处理的控制器进行处理。
		- 我们可以自定义一个异常处理控制器，一旦出现指定异常，就会转接到此控制器执行：
		- ``` java
		  		  		  @ControllerAdvice
		  		  		  public class ErrorController {
		  		  		  - @ExceptionHandler(Exception.class)
		  		  		    public String error(Exception e, Model model){  //可以直接添加形参来获取异常
		  		  		        e.printStackTrace();
		  		  		        model.addAttribute("e", e);
		  		  		        return "500";
		  		  		    }
		  		  		  }
		  ```
		- 接着我们编写一个专门显示异常的页面：
		  ``` java
		  		  		  <!DOCTYPE html>
		  		  		  <html lang="en">
		  		  		  <head>
		  		  		    <meta charset="UTF-8">
		  		  		    <title>Title</title>
		  		  		  </head>
		  		  		  <body>
		  		  		  500 - 服务器出现了一个内部错误QAQ
		  		  		  <div th:text="${e}"></div>
		  		  		  </body>
		  		  		  </html>
		  ```
		- 接着修改：
		- ``` java
		  		  		  @RequestMapping("/index")
		  		  		  public String index(){
		  		  		    System.out.println("我是处理！");
		  		  		    if(true) throw new RuntimeException("您的氪金力度不足，无法访问！");
		  		  		    return "index";
		  		  		  }
		  ```
		- 访问后，我们发现控制台会输出异常信息，同时页面也是我们自定义的一个页面。
	- ## JSON数据格式与AJAX请求
	  collapsed:: true
		- ### 介绍
			- JSON (JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。
			- 我们现在推崇的是前后端分离的开发模式，而不是所有的内容全部交给后端渲染再发送给浏览器，也就是说，整个Web页面的内容在一开始就编写完成了，而其中的数据由前端执行JS代码来向服务器动态获取，再到前端进行渲染（填充），这样可以大幅度减少后端的压力，并且后端只需要传输关键数据即可（在即将到来的SpringBoot阶段，我们将完全采用前后端分离的开发模式）
			-
		- ### JSON数据格式
			- 既然要实现前后端分离，那么我们就必须约定一种更加高效的数据传输模式，来向前端页面传输后端提供的数据。因此JSON横空出世，它非常容易理解，并且与前端的兼容性极好，因此现在比较主流的数据传输方式则是通过JSON格式承载的。
			- 一个JSON格式的数据长这样，以学生对象为例：
			- ``` json
			  			  		  {"name": "杰哥", "age": 18}
			  ```
			- 多个学生可以以数组的形式表示：
			- ``` json
			  			  		  [{"name": "杰哥", "age": 18}, {"name": "阿伟", "age": 18}]
			  ```
			- 嵌套关系可以表示为：
			- ``` json
			  			  		  {"studentList": [{"name": "杰哥", "age": 18}, {"name": "阿伟", "age": 18}], "count": 2}
			  ```
			- 它直接包括了属性的名称和属性的值，与JavaScript的对象极为相似，它到达前端后，可以直接转换为对象，以对象的形式进行操作和内容的读取，相当于以字符串形式表示了一个JS对象，我们可以直接在控制台窗口中测试：
			- ``` js
			  			  		  let obj = JSON.parse('{"studentList": [{"name": "杰哥", "age": 18}, {"name": "阿伟", "age": 18}], "count": 2}')
			  			  		  //将JSON格式字符串转换为JS对象
			  			  		  obj.studentList[0].name   //直接访问第一个学生的名称
			  ```
			- 我们也可以将JS对象转换为JSON字符串：
			- ``` js
			  			  		  JSON.stringify(obj)
			  ```
			- 我们后端就可以以JSON字符串的形式向前端返回数据，这样前端在拿到数据之后，就可以快速获取，非常方便。
			- 那么后端如何快速创建一个JSON格式的数据呢？我们首先需要导入以下依赖：
			- ``` xml
			  			  		  <dependency>
			  			  		    <groupId>com.alibaba</groupId>
			  			  		    <artifactId>fastjson</artifactId>
			  			  		    <version>1.2.78</version>
			  			  		  </dependency>
			  ```
			- JSON解析框架有很多种，比较常用的是Jackson和FastJSON，这里我们使用阿里巴巴的FastJSON进行解析。
			- 首先要介绍的是JSONObject，它和Map的使用方法一样（实现了Map接口），比如我们向其中存放几个数据：
			- ``` java
			  			  		  @RequestMapping(value = "/index")
			  			  		  public String index(){
			  			  		    JSONObject object = new JSONObject();
			  			  		    object.put("name", "杰哥");
			  			  		    object.put("age", 18);
			  			  		    System.out.println(object.toJSONString());   //以JSON格式输出JSONObject字符串
			  			  		    return "index";
			  			  		  }
			  ```
			- 最后我们得到的结果为：
			- ``` json
			  			  		  {"name": "杰哥", "age": 18}
			  ```
			- 实际上JSONObject就是对JSON数据的一种对象表示。同样的还有JSONArray，它表示一个数组，用法和List一样，数组中可以嵌套其他的JSONObject或是JSONArray：
			- ``` java
			  			  		  @RequestMapping(value = "/index")
			  			  		  public String index(){
			  			  		    JSONObject object = new JSONObject();
			  			  		    object.put("name", "杰哥");
			  			  		    object.put("age", 18);
			  			  		    JSONArray array = new JSONArray();
			  			  		    array.add(object);
			  			  		    System.out.println(array.toJSONString());
			  			  		    return "index";
			  			  		  }
			  ```
			- 得到的结果为：
			- ``` json
			  			  		  [{"name": "杰哥", "age": 18}]
			  ```
			- 当出现循环引用时，会按照以下语法来解析：
			  ![img](https://wangguanjingji.oss-cn-beijing.aliyuncs.com/picture/1758707-20190814212141691-1998020800.png)
			- 我们可以也直接创建一个实体类，将实体类转换为JSON格式的数据：
			  ``` java
			  			  		  @RequestMapping(value = "/index", produces = "application/json")
			  			  		  @ResponseBody
			  			  		  public String data(){
			  			  		      Student student = new Student();
			  			  		      student.setName("杰哥");
			  			  		      student.setAge(18);
			  			  		      return JSON.toJSONString(student);
			  			  		  }
			  ```
			  这里我们修改了`produces`的值，将返回的内容类型设定为`application/json`，表示服务器端返回了一个JSON格式的数据（当然不设置也行，也能展示，这样是为了规范）然后我们在方法上添加一个`@ResponseBody`表示方法返回（也可以在类上添加`@RestController`表示此Controller默认返回的是字符串数据）的结果不是视图名称而是直接需要返回一个字符串作为页面数据，这样，返回给浏览器的就是我们直接返回的字符串内容。
			  
			  接着我们使用JSON工具类将其转换为JSON格式的字符串，打开浏览器，得到JSON格式数据。
			  
			  SpringMVC非常智能，我们可以直接返回一个对象类型，它会被自动转换为JSON字符串格式：
			  
			  ``` java
			  			  		  @RequestMapping(value = "/data", produces = "application/json")
			  			  		  @ResponseBody
			  			  		  public Student data(){
			  			  		      Student student = new Student();
			  			  		      student.setName("杰哥");
			  			  		      student.setAge(18);
			  			  		      return student;
			  			  		  }
			  ```
			  注意需要在配置类中添加一下FastJSON转换器（默认只支持JackSon）：
			  
			  ``` java
			  			  		  @Override
			  			  		  public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
			  			  		      converters.add(new FastJsonHttpMessageConverter());
			  			  		  }
			  ```
		- ### AJAX请求
			-
-